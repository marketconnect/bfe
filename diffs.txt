--- a/bfe/api/handlers.go
+++ b/bfe/api/handlers.go
@@ -179,6 +179,17 @@
 	c.JSON(http.StatusOK, gin.H{"message": "permission revoked successfully"})
 }
 
+func (h *Handler) ListAllFoldersHandler(c *gin.Context) {
+	folders, err := h.StorageClient.ListAllFolders()
+	if err != nil {
+		c.JSON(http.StatusBadGateway, gin.H{"error": "failed to list folders from storage service", "details": err.Error()})
+		return
+	}
+
+	c.JSON(http.StatusOK, gin.H{"folders": folders})
+}
+
 // User Handlers
 func (h *Handler) ListFilesHandler(c *gin.Context) {
 	userID, exists := c.Get("userID")
@@ -194,62 +205,51 @@
 		return
 	}
 
-	if len(permissions) == 0 {
+	if len(permissions) == 0 {
 		c.JSON(http.StatusOK, models.ListFilesResponse{Path: "/", Folders: []string{}, Files: []models.FileWithURL{}})
 		return
 	}
 
 	requestedPath := c.Query("path")
 	// If user is at root, show all their permitted folders instead of just the first one.
 	if requestedPath == "" || requestedPath == "/" {
 		var rootFolders []string
 		for _, p := range permissions {
-			rootFolders = append(rootFolders, p.FolderPrefix)
+			rootFolders = append(rootFolders, p.FolderPrefix)
 		}
 		c.JSON(http.StatusOK, models.ListFilesResponse{
 			Path:    "/",
 			Folders: rootFolders,
 			Files:   []models.FileWithURL{},
 		})
 		return
 	}
 
 	// Normalize path for security checks
 	if !strings.HasSuffix(requestedPath, "/") {
 		requestedPath += "/"
 	}
 
-	// Check if the user is allowed to access the requested path
+	// Check if the user is allowed to access the requested path
 	isAllowed := false
 	for _, p := range permissions {
 		if strings.HasPrefix(requestedPath, p.FolderPrefix) {
 			isAllowed = true
 			break
 		}
 	}
 
 	if !isAllowed {
 		c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
 		return
 	}
 
 	// If allowed, proceed to list objects
-	listOutput, err := h.StorageClient.ListObjects(requestedPath, "/")
+	listOutput, err := h.StorageClient.ListObjects(requestedPath, "/")
 	if err != nil {
 		c.JSON(http.StatusBadGateway, gin.H{"error": "failed to list files from storage service", "details": err.Error()})
 		return
 	}
 
 	var filesWithURLs []models.FileWithURL
 	for _, key := range listOutput.Files {
-		url, err := h.StorageClient.GeneratePresignedURL(key, 3600) // 1 hour expiry
+		url, err := h.StorageClient.GeneratePresignedURL(key, 3600) // 1 hour expiry
 		if err != nil {
 			c.Error(err) // Log error
 			continue
 		}
 		filesWithURLs = append(filesWithURLs, models.FileWithURL{Key: key, URL: url})
 	}
 
 	response := models.ListFilesResponse{
 		Path:    requestedPath,
 		Folders: listOutput.Folders,
 		Files:   filesWithURLs,
 	}
 
 	c.JSON(http.StatusOK, response)
 }
--- a/bfe/main.go
+++ b/bfe/main.go
@@ -51,6 +51,7 @@
 				adminRoutes.DELETE("/users/:id", handler.DeleteUserHandler)
 				adminRoutes.POST("/permissions", handler.AssignPermissionHandler)
 				adminRoutes.DELETE("/permissions/:id", handler.RevokePermissionHandler)
+				adminRoutes.GET("/storage/folders", handler.ListAllFoldersHandler)
 			}
 		}
 	}
--- a/bfe/storage_client/client.go
+++ b/bfe/storage_client/client.go
@@ -43,6 +43,29 @@
 	return &result, nil
 }
 
+func (c *Client) ListAllFolders() ([]string, error) {
+	reqURL := fmt.Sprintf("%s/api/v1/list-all-folders", c.BaseURL)
+	resp, err := c.HTTPClient.Get(reqURL)
+	if err != nil {
+		return nil, fmt.Errorf("failed to call storage service: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != http.StatusOK {
+		body, _ := io.ReadAll(resp.Body)
+		return nil, fmt.Errorf("storage service returned status %d: %s", resp.StatusCode, string(body))
+	}
+
+	var result struct {
+		Folders []string `json:"folders"`
+	}
+	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
+		return nil, fmt.Errorf("failed to decode response from storage service: %w", err)
+	}
+	return result.Folders, nil
+}
+
 func (c *Client) GeneratePresignedURL(objectKey string, expires int64) (string, error) {
 	reqURL := fmt.Sprintf("%s/api/v1/generate-url?objectKey=%s&expires=%d", c.BaseURL, url.QueryEscape(objectKey), expires)
 	resp, err := c.HTTPClient.Get(reqURL)